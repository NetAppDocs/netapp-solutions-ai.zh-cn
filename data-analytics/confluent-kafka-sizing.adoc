---
sidebar: sidebar 
permalink: data-analytics/confluent-kafka-sizing.html 
keywords: solution, architecture, details, hardware, software 
summary: 本节介绍 Confluent 认证所使用的硬件和软件。此信息适用于使用NetApp存储的 Kafka 部署。 
---
= 浆纱
:hardbreaks:
:allow-uri-read: 
:nofooter: 
:icons: font
:linkattrs: 
:imagesdir: ../media/


[role="lead"]
Kafka 大小调整可以通过四种配置模式进行：简单、粒度、反向和分区。



== 简单的

简单模式适合首次使用 Apache Kafka 的用户或早期使用案例。对于此模式，您可以提供吞吐量 MBps、读取扇出、保留和资源利用率百分比（默认值为 60%）等要求。您还可以进入环境，例如本地（裸机、VMware、Kubernetes 或 OpenStack）或云。根据这些信息，Kafka 集群的大小提供了代理、zookeeper、Apache Kafka 连接工作器、模式注册表、REST 代理、ksqlDB 和 Confluent 控制中心所需的服务器数量。

对于分层存储，请考虑使用粒度配置模式来确定 Kafka 集群的大小。粒度模式适合经验丰富的 Apache Kafka 用户或定义明确的用例。本节介绍生产者、流处理器和消费者的大小。



=== 生产者

要描述 Apache Kafka 的生产者（例如本机客户端、REST 代理或 Kafka 连接器），请提供以下信息：

* *姓名。*火花。
* *生产者类型。*应用程序或服务、代理（REST、MQTT、其他）和现有数据库（RDBMS、NOSQL、其他）。您也可以选择“我不知道”。
* *平均吞吐量。*以每秒事件数计算（例如 1,000,000）。
* *峰值吞吐量。*以每秒事件数计算（例如 4,000,000）。
* *平均消息大小。*以字节为单位，未压缩（最大 1MB；例如 1000）。
* *消息格式。*选项包括 Avro、JSON、协议缓冲区、二进制、文本、“我不知道”和其他。
* *复制因子。*选项为 1、2、3（Confluent 建议）、4、5 或 6。
* *保留时间。*有一天（例如）。您希望将数据存储在 Apache Kafka 中多长时间？输入 -1 和任意单位可表示无限时间。计算器假设无限保留的保留时间为 10 年。
* 选中“启用分层存储以减少代理数量并允许无限存储？”复选框。
* 启用分层存储后，保留字段控制在代理本地存储的热数据集。档案保留字段控制数据在档案对象存储中的存储时间。
* *档案存储保留。*一年（例如）。您希望将数据保存在档案存储中多长时间？输入 -1 和任意单位可获得无限持续时间。计算器假设无限保留的保留时间为 10 年。
* *增长乘数。* 1（例如）。如果此参数的值基于当前吞吐量，则将其设置为 1。要根据额外增长确定大小，请将此参数设置为增长乘数。
* 生产者实例的数量。 10（例如）。将运行多少个生产者实例？此输入需要将 CPU 负载纳入到尺寸计算中。空白值表示 CPU 负载未纳入计算。


根据此示例输入，尺寸对生产者有以下影响：

* 未压缩字节的平均吞吐量：1GBps。未压缩字节的峰值吞吐量：4GBps。压缩字节的平均吞吐量：400MBps。压缩字节的峰值吞吐量：1.6GBps。这是基于默认的 60% 压缩率（您可以更改此值）。
+
** 所需的代理热集存储总量：31,104TB，包括复制和压缩。所需的总代理外存档存储：378,432TB（压缩）。使用link:https://fusion.netapp.com["https://fusion.netapp.com"^]用于StorageGRID大小调整。




流处理器必须描述从 Apache Kafka 使用数据并返回到 Apache Kafka 的应用程序或服务。大多数情况下，这些都是在 ksqlDB 或 Kafka Streams 中构建的。

* *姓名。*火花飘带。
* *处理时间。*该处理器处理一条消息需要多长时间？
+
** 1 毫秒（简单、无状态转换）[示例]，10 毫秒（有状态的内存操作）。
** 100ms（有状态网络或磁盘操作），1000ms（第三方 REST 调用）。
** 我已经对这个参数进行了基准测试，并且确切地知道需要多长时间。


* *输出保留。* 1天（示例）。流处理器将其输出返回给 Apache Kafka。您希望这些输出数据在 Apache Kafka 中存储多长时间？输入 -1 和任意单位可获得无限持续时间。
* 选中复选框“启用分层存储以减少代理数量并允许无限存储？”
* *档案存储保留。* 1年（例如）。您希望将数据保存在档案存储中多长时间？输入 -1 和任意单位可获得无限持续时间。计算器假设无限保留的保留时间为 10 年。
* *输出直通百分比。* 100（例如）。流处理器将其输出返回给 Apache Kafka。入站吞吐量的百分比将输出回 Apache Kafka？例如，如果入站吞吐量为 20MBps，且该值为 10，则输出吞吐量将为 2MBps。
* 这是从哪些应用程序读取的？选择“Spark”，这是基于生产者类型的大小调整中使用的名称。根据以上输入，您可以预期流处理器实例和主题分区估计的大小会产生以下影响：
* 该流处理器应用程序需要以下数量的实例。传入的主题可能也需要这么多的分区。联系 Confluent 确认此参数。
+
** 1,000 表示平均吞吐量，无增长乘数
** 峰值吞吐量为 4,000，无增长乘数
** 1,000 表示平均吞吐量，并带有增长乘数
** 峰值吞吐量为 4,000，并带有增长乘数






=== 消费者

描述使用来自 Apache Kafka 的数据但不返回到 Apache Kafka 的应用程序或服务；例如，本机客户端或 Kafka 连接器。

* *姓名。*激发消费者。
* *处理时间。*该消费者需要多长时间来处理一条消息？
+
** 1ms（例如，像日志记录这样的简单且无状态的任务）
** 10ms（快速写入数据存储）
** 100 毫秒（数据存储写入速度慢）
** 1000ms（第三方 REST 调用）
** 一些其他已知持续时间的基准测试过程。


* *消费者类型。*应用程序、代理或接收器至现有数据存储（RDBMS、NoSQL 等）。
* 这是从哪些应用程序读取的？将此参数与之前确定的生产者和流大小连接起来。


根据以上输入，您必须确定消费者实例的大小和主题分区估计。消费者应用程序需要以下数量的实例。

* 平均吞吐量为 2,000，无增长乘数
* 峰值吞吐量为 8,000，无增长乘数
* 平均吞吐量为 2,000，包括增长乘数
* 峰值吞吐量为 8,000，包括增长乘数


传入的主题可能也需要这个数量的分区。联系 Confluent 进行确认。

除了对生产者、流处理器和消费者的要求之外，您还必须提供以下额外要求：

* *重建时间。*例如4小时。如果 Apache Kafka 代理主机发生故障，其数据丢失，并且需要配置新主机来替换故障主机，那么这个新主机必须多快重建自身？如果值未知，请将此参数留空。
* *资源利用率目标（百分比）。*例如，60。您希望您的主机在平均吞吐量期间的利用率如何？  Confluent 建议利用率为 60%，除非您使用 Confluent 自平衡集群，在这种情况下利用率可能会更高。




=== 描述你的环境

* *您的集群将在什么环境中运行？*亚马逊网络服务、微软 Azure、谷歌云平台、本地裸机、本地 VMware、本地 OpenStack 还是本地 Kubernates？
* *主人详细信息。*核心数：例如48个，网卡类型（10GbE、40GbE、16GbE、1GbE或其他类型）。
* *存储卷。*主持人：12（例如）。每个主机支持多少个硬盘或 SSD？  Confluent 建议每个主机配备 12 个硬盘。
* *存储容量/卷（以 GB 为单位）。* 1000（例如）。单个卷可以存储多少 GB 的存储空间？  Confluent 建议使用 1TB 磁盘。
* 存储配置。存储卷如何配置？ Confluent 建议使用 RAID10 来充分利用 Confluent 的所有功能。还支持 JBOD、SAN、RAID 1、RAID 0、RAID 5 和其他类型。
* *单卷吞吐量（MBps）。* 125（例如）。单个存储卷每秒的读取或写入速度是多少兆字节？  Confluent 推荐使用标准硬盘，其吞吐量通常为 125MBps。
* *内存容量（GB）。*  64（例如）。


确定环境变量后，选择“Size my Cluster”。根据上面指出的示例参数，我们确定了 Confluent Kafka 的以下大小：

* *Apache Kafka。*经纪人数量：22。您的集群受存储限制。考虑启用分层存储以减少主机数量并允许无限存储。
* Apache ZooKeeper。数量：5；Apache Kafka Connect Workers：数量：2；Schema Registry：数量：2；REST Proxy：数量：2；ksqlDB：数量：2；Confluent Control Center：数量：1。


对于平台团队，请使用反向模式，无需考虑用例。使用分区模式来计算单个主题需要多少个分区。看 https://eventsizer.io[]根据反向和分区模式进行大小调整。
